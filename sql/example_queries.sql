--query1--retrieve past events for a particular user whosoever would be provided
SELECT e.eventID,
       e.eventName,
       e.endDate,
       e.endTime
FROM Events AS e
WHERE e.eventID IN (
    SELECT r.eventID
    FROM Registration AS r
    JOIN Users AS u ON r.userID = u.userID
    WHERE u.username = 'user5'
)
  AND (e.endDate < CURRENT_DATE
  OR (e.endTime <= CURRENT_TIME AND e.endDate = CURRENT_DATE));
-- got the output

--query2-- retrieve upcoming events which are not at full capacity
SELECT e.eventID,
       e.eventName,
       e.endDate,
       e.endTime
FROM Events AS e
WHERE (e.endDate > CURRENT_DATE
       OR (e.endDate = CURRENT_DATE AND e.endTime > CURRENT_TIME))
  AND e.ticketsSold < e.maxAttendees;
 -- got the output

--query3-- find almost full events, events which have 75 percent or more tickets sold but not full 
SELECT e.eventID,
       e.eventName,
       e.endDate,
       e.endTime
FROM Events AS e
WHERE ( e.endDate > CURRENT_DATE
        OR ( e.endDate = CURRENT_DATE AND e.endTime > CURRENT_TIME ) )
  AND e.ticketsSold >= 0.75 * e.maxAttendees
  AND e.ticketsSold < e.maxAttendees;
-- got the output

-- query4-- find avg rating of all events linked to an organiser
SELECT O.organizerID, O.firstName, O.lastName, avg(R.rating) as avg_Rating
FROM organizer as O
JOIN (SELECT E.organizerID as organizerID, F.Rating as rating 
	  FROM events as E
	  JOIN feedback as F
	  ON E.eventID = F.eventID) as R
ON O.organizerID = R.organizerID
GROUP BY O.organizerID;
-- got the output

--query5-- find events which had low tickets sold, less than 33% after they are over
SELECT eventID, eventName, category, ticketsSold, maxAttendees
FROM events
WHERE 3 * ticketsSold < maxAttendees AND (current_date > endDate OR (current_date = endDate AND current_time > endTime));
-- got the output

--query 6 -- find total revenue for a particular event
SELECT E.eventID, 
	(CASE WHEN T.total_amount IS NULL THEN 0 ELSE T.total_amount END) AS revenue
FROM events AS E
LEFT JOIN (
    SELECT eventID, SUM(amount) AS total_amount
    FROM transactions
    WHERE status = 'Processed'  
    GROUP BY eventID
) AS T ON T.eventID = E.eventID;
-- got the output

-- Query 7 - generate a report for the organisers including the avg_rating of his events, total revenue generated by them & total complaints against them.
SELECT X.organizerID, X.avg_rating, X.total_complaints, Y.total_revenue
FROM 	(SELECT A.organizerID, A.total_complaints, B.avg_Rating
		FROM (WITH pending_Complaints as (
				SELECT E.eventID as eventID, E.organizerID as organizerID, C.complaintID, C.Created_At
				FROM events as E
				JOIN complaint as C
				ON E.eventID = C.eventID)
			SELECT organizerID, count(*) as total_complaints
			FROM pending_Complaints
			GROUP BY organizerID) as A
		
		JOIN	(SELECT O.organizerID as organizerID, avg(R.rating) as avg_Rating
				FROM organizer as O
				JOIN (SELECT E.organizerID as organizerID, F.Rating as rating 
					  FROM events as E
					  JOIN feedback as F
					  ON E.eventID = F.eventID) as R
				ON O.organizerID = R.organizerID
				GROUP BY O.organizerID) as B
		ON A.organizerID = B.organizerID) as X
		
JOIN 	(SELECT organizerID, SUM(revenue) as total_revenue
		FROM (SELECT E.eventID as eventID, E.organizerID as organizerID, 
			(E.ticketsSold * E.ticketPrice - CASE WHEN T.refunded_amount IS NULL THEN 0 ELSE T.refunded_amount END) AS revenue
			FROM events AS E
			LEFT JOIN (
			    SELECT eventID, SUM(amount) AS refunded_amount
			    FROM transactions
			    WHERE status = 'Refunded'  
			    GROUP BY eventID
			) AS T ON T.eventID = E.eventID)
		GROUP BY organizerID
		) as Y
ON X.organizerID = Y.organizerID;
-- got the output

--Query 8 - find no of complaint against an organiser has received for an event
WITH total_Complaints as (
	SELECT E.eventID as eventID, E.organizerID as organizerID, C.complaintID, C.Created_At
	FROM events as E
	JOIN complaint as C
	ON E.eventID = C.eventID
)
SELECT organizerID, eventID, count(*) as complaints
FROM total_Complaints
GROUP BY organizerID, eventID
ORDER BY MAX(Created_At) DESC;
-- got the output but pending constraint need some data insertion with status pending
		
-- Query 9 - get the organisers having avg_rating of the events <= x or no. of complaints >= y
SELECT organizerID, username
FROM Organizer
WHERE 4.5 >= (SELECT avg_Rating
			FROM 	(SELECT O.organizerID as orgID, avg(R.rating) as avg_Rating
					FROM organizer as O
					JOIN (SELECT E.organizerID as organizerID, F.Rating as rating 
						  FROM events as E
						  JOIN feedback as F
						  ON E.eventID = F.eventID) as R
					ON O.organizerID = R.organizerID
					GROUP BY O.organizerID)
			WHERE orgID = organizerID)
	OR 
	4 <=	(SELECT complaints
			FROM 	(WITH pending_Complaints as
					(SELECT E.eventID as eventID, E.organizerID as orgID, C.complaintID, C.Created_At
					FROM events as E
					JOIN complaint as C
					ON E.eventID = C.eventID)
				SELECT orgID, count(*) as complaints
				FROM pending_Complaints
				GROUP BY orgID)
			WHERE organizerID = orgID);
-- got the output

--query 10---find all unverified organizers linked to an admin
SELECT a.staffID, o.organizerID
FROM Admins AS a
JOIN Organizer AS o ON a.staffID = o.staffID
WHERE o.verificationStatus = FALSE
ORDER BY a.staffID;
-- got the output

--query11-- find organisers who have the best attended events
SELECT 
    o.organizerID,
    o.username,
    o.organization,
    AVG((e.ticketsSold * 100.0) / e.maxAttendees) AS avg_percentage_sold
FROM 
    Organizer AS o
JOIN 
    Events AS e ON o.organizerID = e.organizerID
GROUP BY 
    o.organizerID, o.username, o.organization
ORDER BY 
    avg_percentage_sold DESC;
-- got the output

--query12 --get number of events registrations for a particular organiser including those which may have no entries
SELECT 
    E.eventID, 
    E.eventName, 
    COUNT(DISTINCT R.RegistrationID) AS totalRegistrations
FROM Events E
LEFT OUTER JOIN Registration R ON E.eventID = R.eventID
WHERE E.organizerID = 3  -- Replace with actual organizer ID
GROUP BY E.eventID, E.eventName
ORDER BY totalRegistrations DESC;
-- got the output

-- query13 -- (MEMBERSHIP TEST) get the users who attended both types of events, Concert and Food
(SELECT R.userID
FROM Events as E
JOIN Registration as R
ON E.eventID = R.eventID
WHERE category = 'Concert')
INTERSECT
(SELECT R.userID
FROM Events as E
JOIN Registration as R
ON E.eventID = R.eventID
WHERE category = 'Food');
-- got the output

-- query-14: find the most active users, who attended more than x events
SELECT U.userID, U.username, COUNT(R.eventID) AS events_attended
FROM Users U
JOIN Registration R ON U.userID = R.UserID
GROUP BY U.userID, U.username
HAVING COUNT(R.eventID) > 5;
